<script>
function cal (x,y){
    this.x =x;
    this.y =y;
}

//기존 문법은 클래스가 없어 prototype사용
//인스턴스 함수 추가 
cal.prototype.plus = function(){
    return this.x+this.y;
}
//prototype을 통해서 객체 추가 -> 걍 객체 따로 추가하는거랑 크게 차이 없음 
//예약어 사용하는 것  prototye하면, 클래스 단에서 추가 가능 
//객체에 그냥 속성 추가하는건 그 객체에만 해당 

cal.prototype = {
    plus: function(){
        return this.x+this.y;
    },
    minus : function(){
        return this.x - this.y;
    }
}

class Calculator2{
    constructor(x,y){
        this.x=x; //this를 통한 추가는 prototype과 가까움! -> 객체 단에 추가하는 것보단
        this.y=y;
    }
    plus(){
        return this.x+this.y;
    }
    minus(){
        return this.x - this.y;
    }
}

//상속
class Calc3 extends Calculator2{
    constructor(x,y,z){
        super(x,y);
        this.z=z;
    }
    plus2() {
        return this.x+this.y+this.z;
    }
}

//계단형 함수 
function plus(x){
    return function (y) {
        return x+y;
    };
}

//함수 리턴 -> 리턴함수 실행해주는건아님
//중요한 점은 outer function에서 지역변수를 inner에서 기억한다는점!! 

console.log(plus(1)(2));

function p(x){
    function ss(y){
        console.log(x);
    }
    ss(1);
    //console.log(y); closer개념
}
console.log(p(2));

var p = x => y => x+y;
console.log(p(1)(2));
</script>